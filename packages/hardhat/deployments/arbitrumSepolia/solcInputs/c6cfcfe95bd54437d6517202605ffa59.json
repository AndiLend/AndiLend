{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/AndinLend.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\n/**\n * A smart contract that allows users to create loans requests and lenders to borrow USDTs\n * Also returns the lender the borrowed money.\n */\ncontract AndinLend {\n\tstruct Loan {\n\t\tuint amount;\n\t\tuint balanceDue;\n\t\tuint loanTime;\n\t\tuint fee;\n\t\tuint8 interest;\n\t\tuint8 qualification;\n\t\tuint8 pendingFeesCount;\n\t\tuint8 status;\n\t}\n\n\tmapping(address => Loan) public loans;\n\tmapping(address => address) private borrowerToLender;\n\tmapping(address => address[]) private lenderToBorrowers;\n\tmapping(address => uint8) public borrowerQualification;\n\taddress[] private borrowersRegister;\n\n\tevent RequestedLoan(address borrower, Loan loan);\n\n\tevent GrantedLoan(address borrower, address lender, Loan loan);\n\n\tevent PaidFee(address borrower, address lender, Loan loan);\n\n\tevent FinishLoan(address borrower, address lender, Loan loan);\n\n\tIERC20 private erc20USDT;\n\taddress public owner;\n\tbool private isERC20Added = false;\n\taddress public erc20USDTAddress;\n\n\tconstructor() {\n\t\towner = msg.sender;\n\t}\n\n\tfunction setERC20ContractAddress(address _erc20USDTAddress) external {\n\t\trequire(isERC20Added == false, \"Contract address is already added.\");\n\t\trequire(\n\t\t\tmsg.sender == owner,\n\t\t\t\"Only owner can modify the ERC20 Address.\"\n\t\t);\n\t\terc20USDT = IERC20(_erc20USDTAddress);\n\t\tisERC20Added = true;\n\t\terc20USDTAddress = _erc20USDTAddress;\n\t}\n\n\tfunction requestLoan(\n\t\tuint _amount,\n\t\tuint _loanTime,\n\t\tuint8 _interest,\n\t\tuint8 _pendingFeesCount\n\t) external isERC20AddedModifier {\n\t\trequire(\n\t\t\tloans[msg.sender].loanTime == 0 || loans[msg.sender].status == 2,\n\t\t\t\"Each user can only have one active loan.\"\n\t\t);\n\t\tuint dueMonths = _loanTime / 2628000;\n\t\tuint balanceDue = ((_interest * dueMonths * _amount) / 100) + _amount;\n\t\tuint fee = balanceDue / _pendingFeesCount;\n\t\tuint8 qualification = borrowerQualification[msg.sender];\n\t\tLoan memory newLoanRequest = Loan(\n\t\t\t_amount,\n\t\t\tbalanceDue,\n\t\t\t_loanTime,\n\t\t\tfee,\n\t\t\t_interest,\n\t\t\tqualification,\n\t\t\t_pendingFeesCount,\n\t\t\tuint8(0)\n\t\t);\n\t\tif (loans[msg.sender].status != 2) {\n\t\t\tborrowersRegister.push(msg.sender);\n\t\t}\n\t\tloans[msg.sender] = newLoanRequest;\n\t\temit RequestedLoan(msg.sender, newLoanRequest);\n\t}\n\n\tfunction grantLoan(address _borrower) external isERC20AddedModifier {\n\t\trequire(\n\t\t\tloans[_borrower].loanTime != 0,\n\t\t\t\"The client does not have a loan requirement\"\n\t\t);\n\t\trequire(loans[_borrower].status == 0, \"The loan is not pending\");\n\t\trequire(\n\t\t\terc20USDT.balanceOf(msg.sender) > loans[_borrower].amount,\n\t\t\t\"Insufficient USDT balance.\"\n\t\t);\n\t\trequire(\n\t\t\terc20USDT.allowance(msg.sender, address(this)) >=\n\t\t\t\tloans[_borrower].amount,\n\t\t\t\"Insufficient USDT balance allowance.\"\n\t\t);\n\n\t\terc20USDT.transferFrom(msg.sender, _borrower, loans[_borrower].amount);\n\t\tloans[_borrower].status = 1;\n\t\tborrowerToLender[_borrower] = msg.sender;\n\t\tlenderToBorrowers[msg.sender].push(_borrower);\n\t\temit GrantedLoan(_borrower, msg.sender, loans[_borrower]);\n\t}\n\n\tfunction payFee(address _lender) external isERC20AddedModifier {\n\t\trequire(\n\t\t\tloans[msg.sender].loanTime != 0,\n\t\t\t\"Client does not have an active loan.\"\n\t\t);\n\t\trequire(loans[msg.sender].status == 1, \"The loan is not active.\");\n\t\trequire(\n\t\t\terc20USDT.balanceOf(msg.sender) > loans[msg.sender].fee,\n\t\t\t\"Insufficient USDT balance.\"\n\t\t);\n\t\trequire(\n\t\t\tborrowerToLender[msg.sender] == _lender,\n\t\t\t\"The address is not the lender of this loan.\"\n\t\t);\n\n\t\terc20USDT.transferFrom(msg.sender, _lender, loans[msg.sender].fee);\n\t\tloans[msg.sender].pendingFeesCount =\n\t\t\tloans[msg.sender].pendingFeesCount -\n\t\t\t1;\n\t\temit PaidFee(msg.sender, _lender, loans[msg.sender]);\n\t\tif (loans[msg.sender].pendingFeesCount == 0) {\n\t\t\tfinishLoan(_lender);\n\t\t}\n\t}\n\n\tfunction finishLoan(address _lender) private {\n\t\tloans[msg.sender].status = 2;\n\t\temit FinishLoan(msg.sender, _lender, loans[msg.sender]);\n\t}\n\n\tfunction getLenderByBorrowerAddress(\n\t\taddress _borrower\n\t) external view returns (address) {\n\t\treturn borrowerToLender[_borrower];\n\t}\n\n\tfunction getLoansByLend(\n\t\taddress _lender\n\t) external view returns (Loan[] memory) {\n\t\tuint loansByLendCount = lenderToBorrowers[_lender].length;\n\t\tLoan[] memory loansByLend = new Loan[](loansByLendCount);\n\t\taddress[] memory borrowers = lenderToBorrowers[_lender];\n\n\t\tfor (uint i = 0; i < borrowers.length; i++) {\n\t\t\taddress borrower = borrowers[i];\n\t\t\tloansByLend[i] = loans[borrower];\n\t\t}\n\n\t\treturn loansByLend;\n\t}\n\n\tfunction getAllLoans()\n\t\texternal\n\t\tview\n\t\treturns (Loan[] memory, address[] memory)\n\t{\n\t\tuint addressesCount = borrowersRegister.length;\n\t\tLoan[] memory allLoans = new Loan[](addressesCount);\n\n\t\tfor (uint i = 0; i < addressesCount; i++) {\n\t\t\taddress borrower = borrowersRegister[i];\n\t\t\tallLoans[i] = loans[borrower];\n\t\t}\n\n\t\treturn (allLoans, borrowersRegister);\n\t}\n\n\t// get all loans with status = 0\n\tfunction getAllPendingLoans()\n\t\texternal\n\t\tview\n\t\treturns (Loan[] memory, address[] memory)\n\t{\n\t\tLoan[] memory pendingLoans = new Loan[](borrowersRegister.length);\n\t\tfor (uint i = 0; i < borrowersRegister.length; i++) {\n\t\t\taddress borrower = borrowersRegister[i];\n\t\t\tif (loans[borrower].status == 0) {\n\t\t\t\tpendingLoans[i] = loans[borrower];\n\t\t\t}\n\t\t}\n\t\treturn (pendingLoans, borrowersRegister);\n\t}\n\n\tfunction addBorrowerQualification(\n\t\taddress _borrower,\n\t\tuint8 _qualification\n\t) external {\n\t\tborrowerQualification[_borrower] = _qualification;\n\t}\n\n\tmodifier isERC20AddedModifier() {\n\t\trequire(\n\t\t\tisERC20Added == true,\n\t\t\t\"USDT contract address is not added by the owner, yet.\"\n\t\t);\n\t\t_;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}